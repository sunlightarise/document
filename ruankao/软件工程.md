
### 软件开发方法
#### 软件开发方法
##### 结构化法 （谱图模型）
* 用户至上
* 严格区分工作阶段，每个阶段有任务与成果 （流程固话、修改起来比较麻烦）
* 强调系统开发过程的整体性和全局性
* 系统开发过程化，文档资料标准化
* 自顶向下，逐步分解（求精）

##### 原型法
* 适用于需求不明确的开发
* 包括抛弃原型和进化型原型

##### 面向对象方法 （系统的元素跟实现生活相结合）
* 更好的复用性
* 关键在于建立一个全面、合理、统一的模型
* 分析、设计、实现三个阶段、界限不明确

##### 面向服务的方法 （构件）
* SO方法有三个主要的抽象级别：操作、服务、业务流程 
* SOAD分为三个层次：基础设计层（底层服务构件）、应用结构层（服务之间的接口给和服务级协定）
和业务组织层（业务流程建模和服务流程编排）
* 服务建模：分为服务发现、服务规约和服务实现三个阶段

#### 软件开发模型

##### 瀑布模型
       软件设计
定义阶段    需求分析
               软件设计
                   程序编码
开发阶段                软件测试
维护阶段                   运行维护

阶段明析，适合于需求明确的项目

##### 演化模型
* 
        
##### 增量模型
*

##### 螺旋模型

* 制定计划
* 风险分析
* 实施工程
* 客户评估

##### 快速原型模型

* RAD 快速开发

##### 喷泉模型

* 面向对象

##### VI模型

测试模型，测试贯穿始终（敏捷开发-测试驱动）

* 需求分析
* 概要设计
* 详细设计
* 编码
* 单元测试
* 集成测试
* 系统测试
* 验收测试

##### 构件组装模型

* 需求分析和定义
* 软件架构设计
* 构件库的建立（构件库 => 构件获取、构件管理）（构件标准 => CORBA、 COM/DCOM、EJB）
* 应用软件构建
* 测试和发布


##### 统一过程

用例驱动、以架构为中心、迭代和增量

* 初始 （开发模型、开发方法、开发过程方法）
**确定项目范围和边界**
* 识别系统的关键用例
* 展示系统的候选架构
* 估计项目费用和时间
* 评估项目风险

* 细化（完成了架构设计）
* 分析系统问题领域
**建立软件架构基础**
* 淘汰最高风险元素

* 构建 
* 开发剩余的构件
**构件组装与调试**

* 交付
* 进行β测试
**制作发布版本**
* 用户文档定稿
* 确认新系统
* 培训、调整产品

##### 敏捷方法

* 自适应开发
* 水晶方法
* 特征驱动开发
* 极限编程
* 基本原则

    1. 短平快的会议
    2. 小型版本发布
    3. 较少的文档
    4. 合作为重
    5. 客户直接参与
    6. 自动化测试
    7. 适应性计划调整
    8. 结对编程
    9. 测试驱动开发
    10. 持续集成
    11. 重构 
* 大价值观
    1. 沟通
    2. 简单
    3. 反馈
    4. 勇气
* 5大原则
    1. 快速反馈
    2. 简单性假设
    3. 逐步修改
    4. 提倡更改
    5. 优质工作
* 12 大最佳实践

|  - | - | 
| :------| :------ | 
| 计划游戏 | 结对编程 | 
| 小型发布 |集体代码所有制 |
| 隐喻 |持续集成 |
| 简单设计 |每周工作40小时 |
| 测试先行 |现场客户 |
| 重构 |编码标准 |

* 敏捷开发方法（核心）


XP (Extreme Programming, 极限编程) 在所有的敏捷型方法中，XP是最
引人瞩目的。它源于Smalltask圈子，特别Kent Beck 和 Ward Cunningham 
在20世纪80年代末的密切合作。XP在一些对**费用控制严格的公司中使用**，已经被证明**非常有效**的

Cockburn 的水晶系列方法， 水晶系列方法是由Alistair Cockburn 提出的。他与XP方法一样
都是以人为中西你的理念，但是在实践上有所不同。Alistair 考虑到人们一般很难严格遵循一个纪律
约束很强的过程，因此，与XP在高度纪律性不同，Alistair 探索了 **用最少纪律约束而任能成功的的方法**。
从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够
接受并遵循它。

开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是
**程序开发人员在地域上分布很广**。这使得它和其他敏捷方法不同，因为一般的冥界方法都强调项目组成员在同一地点工作，
开放源码的一个突出特点就是查错排障（debug）的高度并行性，任何人发现错误都可将改正源码的“补丁”文件发给维护者
然后由维护者将这些“补丁”或是新增的代码并入源码库


SCRUM, SCRUM 已经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即
**明确定义了的可重复的方法过程**只限于在明确定义了的可重复的环境中，为明确定了了的可重复的人员所用，去
解决明确定义了的可重复的问题

Coad 的功能驱动方法（FDD-Feature Driven Development）
FDD 是由Jeff De Luca 和大师 Peter Coad 提出来的，像其他方法一样。它致力于短时期的迭代阶段和可见可用
的功能。在FDD中，一个迭代周期一般是2周。
在FDD中，编程开发人员分成两类 **首席程序员和“类”程序员**（class owner）,首席程序员是最富有经验的
开发人员，他们是项目的协调者，设计者和指导者，而“类”程序员主要是做源码编写

ASD方法，ASD（Adaptive Software Development）方法是由Jim Highsmith 提出，其核心是三个非线性的，
重叠的开发阶段：**猜测、合作与学习**
 
#### 构件与软件重用


#### 逆向工程


阶段：现有系统  -> 再工程 -> 新系统
     逆向工程  -> 考虑新需求 -> 正向工程

* 实现级
  包括程序的抽象语法树、符号表、过程的设计表示
* 结构级
  包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构
* 功能级
  包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型
* 领域级
  包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型
  


#### 净室软件工程


* 净室即无尘室、洁净室。也就是一个受控污染级别的环境
* 使用盒结构规约（或形式化方法）进行分析和设计模型，并且强调将正确性验证，而不是测试，
作为发现和消除错误的主要机制
* 使用统计的测试来获取认证被交付的软件的可靠性必须的出错率信息


### 需求工程
#### 概述
软件需求是指用户对系统的在功能、行为、性能、设计的约束等方面的期望
软甲你需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他
正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明

需求开发（技术）：需求获取、需求分析、需求定义（严格定义、原型法）、需求验证（需求基线）
需求管理（管理）：变更控制（需求基线）、版本控制、需求跟踪、需求状态跟踪

##### 需求获取

需求获取方法：收集资料、联合讨论会、用户访谈、书面调查、现场观摩、参加业务实践、阅读历史文档、朝阳调查

需求分类： 业务需求（总体的、目标性的）、用户需求（用户视角的内容）、系统需求、功能需求、性能需求、设计约束、基本需求、期望需求、兴奋需求