1、基本简介
2、两种用法：对象锁，类锁
3、多线程访问同步方法的7种情况

Sysnchronized 性质：可重入、不可中断

加锁原理，可重入原理，可见性原理

Synchronized 缺陷：效率低，不够灵活，无法预判是否成功获得锁

Synchronized 的作用
同步方法支持一种简单的策略来防止线程和内存一致性错误；如果一个对象多个线程可见，则对该对象变量的所有读取或者写都是通过同步方法完成的

能够保证同一时刻最多只有一个线程执行该行代码或代码块，以达到并保证并发安全的效果

Synchronized 是 Java的关键字，被Java语言原生支持。


第一种用法：对象锁
方法锁（默认锁对象为this 当前实例对象）和同步代码块（手动指定锁对象）
类锁

第二种用法：类锁
指synchronized 修饰静态方法或指定锁为Class对象

Java 类可能有多个独享，但是只有一个Class对象
类锁锁的是Class 对象
类锁在同一时刻只能被一个对象拥有

1、synchronized 加在static 方法上
2、synchronized （*.class） 代码块


多线程访问同步方法的7种情况
1、2个线程同时访问一个对象的同步方法。（锁的是同一个对象，执行过程中会相互等待，线程同步）
2、2个线程访问的是两个对象的同步方法。（锁对象不同，无法线程同步）
3、两个线程访问的是synchronized的静态方法。（静态方法默认锁当前类势力，由于类实例只有一个所以，可以实现线程同步）
4、同时访问同步方法与非同步方法 （synchronized 只会作用与被修饰对象或者方法，不会影响其他对象或者方法）
5、访问同一个对象的不同的普通同步方法 （如果对象相同，两个方法被 sychronized 修饰的方法先后调用 只能被串行执行，因为他们锁的是同一个对象（当前对象））
6、同时访问静态synchronized 和非静态synchronized方法 （非静态类，锁对象指的是当前实例对象，静态类，锁的对象是当前类的类对象）
7、方法抛出异常后，会释放锁。 （抛出异常后，锁会被释放，下一个线程可以得到锁）

7 种情况总结：3点核心思想
1、一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5情况）
2、每个实例都对应有自己的一把锁，不同实例之间互不影响，例外：锁对象是*.class 以及 synchronized 修饰的是static 方法的时候所有对象共用一把类锁，（对应2、3、4、6 种情况）
3、无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应7种情况）


可重入性-理论

1、可重入
什么是可重入:  指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。
典型的可重入锁：synchronized , ReentrantLock
好处：避免死锁，提升封装性
粒度：线程而非调用（用3种情况来说明pthread 的区别）

情况1、证明同一个方法是可重入的
情况2、证明可重入不要求是同一个方法
情况3、证明可重入不要求是同一个类中的

总结：同一个锁是在同一个线程内可以重入的

2、不可中断
一旦这个锁已经被别人获得了，如果我还想获得锁，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去。

相比之下，未来会介绍 Lock 类，可以拥有中断的能力，第一点，如果我觉得等待的时间太长了，有权利中断现在已经获得的锁的线程的执行，第二点，如果我觉得等待的时间太长了，不想等待了，也可以退出。

六、深入原理
加锁和释放锁的原理：现象，时机，深入JVM字节码。
可重入原理：加锁次数计数器。
保证可见性的原理。

加锁和释放锁的原理：
现象
获取和释放锁的时机，内置锁
等价代码
深入JVM看代码字节码：反编译，monitor指令
  概况，
  反编译，
    可以通过javap 反编译 .class 文件
  Monditorenter， Monditorexit 指令

可重入原理：加锁次数计数器
     JVM 负责跟踪对象被加锁的次数
     线程第一次给对象加锁的时候，计数变为1。此当这个相同的线程在此对象上再次获得锁时，计数会递增。
     每当任务离开时，计数递减，当计数为0的时候，锁被完全释放

可见性：Java 内存模型 （JMM）
1、在synchronized
在得到锁的时候都是在主内存中去读取

synchronized 的缺陷
  效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。
  不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的
  无法知道是否成功获取到锁

思考
1、多个线程等待同一个synchronized 锁的时候，JVM如何选择下一个获取锁的是那个线程？
随机不可控
2、Synchronized 使得同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？
锁得范围不宜过大
3、我想更灵活控制锁得获取和释放（现在释放锁得时机都被规定死了）怎么办？
通过Lock 来实现锁
4、说明锁得升级、降级、什么是JVM里的偏斜锁、轻量级锁、重量级锁？

1、注意使用点：锁对象不能为空，所用域不宜过大、避免死锁
2、如何选择Lock 和Synchronized 关键字
如果可以使用JVM包装同步线程安全的类。
建议使用Synchronized 
自定义较强的采用lock
3、多线程访问同步方法的各种情况


JVM会通过使用monitor 来加锁和解锁。保证同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。