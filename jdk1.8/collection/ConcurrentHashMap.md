### ConcurrentHashMap

#### 概述
支持获取的完全并发和更新的所期望可以调整的并发哈希表。此类遵循HashTable 相同的功能规范，并且包括对应于HashTable 的每一个方法的版本. 不过
尽管所有操作都是线程安全的。但获取操作不必锁定， 并且不支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与HashTable 进行互操作，
这个取决于线程安全，而与其同步细节无关。

获取操作（包括get）通常不会阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。获取会影响完成的更新操作的结果。 对于这些聚合操作， 比如
putAll 和clear, 并发操作坑你只会影响某些条目的插入和移除，类似的，在创建迭代器/枚举时或自此之后， Iterators, 和 Enumerations 返回在某
一时间点上影响哈希表状态的元素，它们不会抛出java.util.ConcurrentModificationException , 不过，迭代器被设计成每次仅由一个线程使用。
记住，聚合结果状态的方法包括 size、isEmpty、containsValue 通常是在其他线程发生并发更新，否则这些方法的结果只是反映了瞬态，可以是用来
监控或者估算，但是不能用来做程序控制。

当存在太多的冲突（即，具有不同的哈希码但是以表的大小为模录入相同的间隙的秘钥）时， 该表被动态拓展，并且每个保持大致2个bin的预期平均效果
（对应与 0.75 负载因子阈值调整大小）。由于映射被添加和删除，这个平均值可能会有所差异，但是总的来说，这为哈希表保留了普遍接受的时间/空间权衡
然而，调整这个或任何其他类型的散列表可能是相对较慢的操作。 如果可能，最好提供一个尺寸评估作为可选的initialCapacity 构造函数参数， 附加
可选的loaderFactor 构造函数提供另外的手段，通过制定在计算给定数量的元素时要分配的空间量时使用的表密集度来制定初始容量。此外，为了与此类
的先前版本兼容，构造函数可以选择制定预期的concurrencyLevel 作为内部大小调整的附件提示， 请注意，使用完全相同的许多键hashCode()是降低
任何哈希表的hashCode的一种可靠的方法。为了改善影响， 当按键为Comparable 时， 该类可以使用键之间的比较顺序来帮助打破关系。

创建一个投影的ConcurrentHashMap 可以（使用被创建的newKeySet() 或 newKeySet(int)）, 或观察（使用 keySet(Object) 获取所有的键）,
并且被映射的值是（可能瞬时）不使用或全部相同的映射值。

ConcurrentHashMap 可以通过使用 LongAdder 值并通过 computeIfAbsent 进行初始化，将其作为一个可缩放的频率映射（直方图或多集的形式），
例如：向 ConcurrentHashMap<String, LongAdder> freqs 添加计数， 可以使用freqs.computeIfAbsent( k-> new LongAdder).increment()

此类及视图和迭代器实现所有的可选方法Map 和 Iterator 接口

**像 HashTable 但不像 HashMap, 这个类不允许null的作用或键值。**

ConcurrentHashMaps 支持一组顺序和并行批量操作, 与大多数的 Stream 方法不同， 他们被设计为安全且经常频繁的使用， 即使是由其他线程同时更新的映射
例如： 当计算共享注册表中的值的快照摘要时。 有三种操作，每种具有四种形式， 接受键、值，条目和（键、值）参数和/或返回值的函数。由于
ConcurrentHashMap 的元素不以任何特定的方式排序， 并且可能会在不同的并行执行中以不同的顺序进行处理，因此提供的函数的正确性不应取决于任何排序
也不应该依赖于可能瞬时变化的任何其他对象或值计算进行中; 除了每一个行动， 理想情况下都是无副作用的。 对Map.Entry 对象的批量操作不支持方法setValue

* forEach: 每一个元素执行给定的操作, 变量形式在执行操作之前对每个元素应用给定的变换。 
* search:  返回在每个元素上应用给定函数的第一个可用非空结果; 当找到结果时跳过进一步的搜索。
* reduce: 累积每一个元素， 提供的减少功能不能依赖于排序（更正式地，它应该是关联的交换）。 有五种辩题：
    * 平原减少（由于没有相应的返回类型，因此（key, value）函数参数没有这种方法的形式）
    * 映射的减少累积了应用于每个元素的给定函数的结果
    * 使用给定的基础值减少标量, double , int 。
    
这些批量操作接受一个 parallelismThreshold 参数， 如果估计当前集合大小小于给定阈值，则方法惊醒一次进行。使用Long.MAX_VALUE. 的值
Long.MAX_VALUE 抑制所有的并行性。使用1的值可以通过划分足够的子任务来完全利用与所有并行计算的ForkJoinPool,commonPool() 来实现最大并行度。
通常，您最初将选择其中一个极值然后测量使用中间值之间的新跟那个，从而降低开销与吞吐量之间的关系。

批量操作

作为参数提供的搜索

接受和/或

批量操作坑内突然完成，

与顺序形式相比，

所有任务方法所有参数必须是非空值