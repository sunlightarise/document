### HosSpot虚拟机

#### 简介
* Amdahl定律（给定问题的并行加速受到问题的连续部分的限制）意味着大多数工作负载无法完美并行化; 某些部分始终是顺序的，不会受益于并行性。Java平台也是如此。特别是，Oracle Java 1.4之前的Java平台虚拟机不支持并行垃圾收集，因此垃圾收集对多处理器系统的影响相对于其他并行应用程序而言也在增长。

垃圾收集器cpu中话费的时间百分比

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

* 这表明在小型系统上开发时可忽略不计的速度问题可能成为扩展到大型系统时的主要瓶颈。但是，减少这种瓶颈的微小改进可以在性能上产生很大的提高。对于足够大的系统，选择正确的垃圾收集器并在必要时进行调整是值得的。

### Ergonomics
* 服务器定义 
  * 内核数量大于2
  * 内存大于2G
  将安装 Server VM 版本
  
* 默认参数以及配置
  * 初始堆大小为1/64的物理内存，最大为1GB
  * 最大堆大小为1/4物理内存，最大为1GB
 

### Generations

* 内存模型

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

在初始化的时候，实际上并未分配物理内存，对象存储保留完整地址给空间可分为，年轻代和年老代

  * 堆
     
     * 堆参数说明
        ![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_006_prm_gn_sz.png)
        
     * 堆大小的设置规则
         * 除非遇到暂停问题，尽可能的为虚拟机尽可能的设置更多的内存，默认大小通常太小
         * 通过从虚拟机中删除最终小的大小决策， 设置-Xms和-Xmx相同值可提高可预测性，但是如果做出了糟糕的选择，
    则虚拟机无法进行补偿
         * 通常，增加处理器数量时增加内存，因为分配可以并行化
             
     * 年轻代, 年轻代通过参数NewRatio控制，设置-XX:NewRatio=3意味着，年轻代和年老代之间的比例是1:3
换句话说，伊甸区和幸存区的组合大小将是总堆大小的1/4
     * 幸存区, 幸存区通过参数SurvivorRatio来调整幸存区大小， 这个通常对性能影响不大。例如：-XX:SurvivorRatio=6将伊甸区和幸存区空间比率设置
为6:1,换句话说，每个幸存区空间是伊甸区的六分之一，因此是年轻代的八分之一（不是七分之一，应为有两个幸存区）
     * 

### Available Collectors

* 串行垃圾收集器，适合单处理器机器
  设置 -XX:+UseSerialGC
  
* 并行收集器,默认启用并行压缩。设置-XX:+UserParallelGC

* 大中型数据采集程序
  CMS收集器 -XX:+UseConcMarkSweepGC;
  G1收集器 -XX:+UseG1GC
  
* 选择垃圾回收器
  * 程序具有较小的数据集（100MB）选择-XX:+UseSerialGC
  * 如果单个处理器上运行且没有暂停时间要求，则让VM选择收集器，或者选择带有该选项的串行收集器-XX:+UseSerialGC
  * 如果（a）峰值应用程序是第一优先级并且（b）没有暂停时间要求或1秒或更长的暂停时间可以接受，那么选择-XX:+UseParallelGC
  * 如果响应时间比总吞吐量更重要，并且垃圾收集暂停必须保存短于大约1秒，则使用-XX:+UseConcMarkSweepGC 或者选择并发收集器 -XX:+UseG1GC

说明：
-Xms 表示Java虚拟机堆初始内存分配大小
-Xmx 表示Java虚拟机堆内存可分配的最大上限


### The Parallel Collector
* 并行收集器，也称为吞吐量收集器，是类似于串行收集器的分代收集器，主要区别于**多线程用于加速垃圾收集器**。默认情况下， 
使用此选项，并行执行次要和主要集合，进一步减少垃圾收集开销。

* 默认情况下，在服务器级计算机选择并行收集器。此外，并行收集器使用自动调整方法，允许您指定特定行为，而不是生成大小和其他低优先级
我们可以指定最大垃圾收集暂停时间，吞吐量和占用时间。
  * 最大垃圾收集暂停时间：使用命令行选项指定-XX:MaxGCPauseMillis=<N>，
  * 吞吐量：吞吐量目标是根据垃圾回收话费的时间之外说话费的时间来衡量的。命令行选项。-XX:GCTimeRatio=<N> 设置垃圾收集时间与应用程序时间的比率
1/(1 + <N>)。 例如，-XX:GCTimeRatio=19将目标设置为垃圾收集总时间的 1/20或1/5， 默认值为99，导致垃圾回收的时间为1%
  * FootPrint：最大堆内存设置使用-Xmx<N>, 此外，只要满足其他目标，收集器就可以隐含的目标，即最小堆大小。

* 设置参数的优先级
  * 最大暂停时间目标
  * 吞吐量目标
  * 最小足迹目标
  
* 默认堆大小。如果不指定，默认是根据计算机内存大小来计算的。
* 客户端JVM默认初始值和最大堆大小
  * 默认的最大堆大小是物理内存的一半，直到物理内存大小为192MB， 否者为物理内存的四分之一，物理内存大小为1GB
   例如：计算机的物理内存为128MB， 那么最大堆大小为64MB, 当等于1GM的时候，最大堆大小为256MB
  * 除非程序创建足够的对象来需要，否则JVM实际上不会使用最大堆大小，在JVM初始化期间分配一个小得多的数量，称为初始堆大小，此数量最小为8MB，
否则为物理内存的1/64,最大物理内存大小为1GB。分配给年前代的最大空间量是总堆大小的1/3。

* 服务器JVM默认初始和最大堆大小
  * 默认的初始和最大堆大小在服务器JVM上的工作方式和客户端JVM的大小相同，只是默认值更高。32位操作系统4G或者更多物理内存，默认最大堆大小可以达到1GB
在64位JVM上，如果128GB，默认堆大小最多可以达到32GB。 

* OOM 是由于GC回收时间过长导致 OutOfMemoryError
  1. 并行垃圾回收器抛出OOM的条件： 垃圾收集器中话费了超过98%的总时间并且回收不了2%的堆。
  2. 处理方案如果为了防止程序运行时间过长，同时堆太小没有进度可以通过添加 -XX:-UseGCOverheadLimit
  
### The Mostly Concurrent Collectors
* 常见的垃圾回收器
  * Concurrent Mark Sweep (SMS) Collector SMS 收集器， 垃圾回收器适合较短的垃圾收集暂停可以与垃圾收集共享处理器资源的应用程序。
  * Garbage-First Garbage Collector  G1 收集器，适用于大内存服务器，它高概率满足垃圾回收器暂停时间目标，同时实现高吞吐量。

* 并发的开销
  1. 大多数并发收集器交互处理器资源，以缩短收集暂停时间。  最明显的开销就是在集合的并发部分期间使用一个或者多个处理器，在N处理系统上，结合的并发部分将使用处理器的KIN， 其中1<= k <= ceiling{1/4}.
（注意K的精确选择和界限可能会发生变化）除了在并发阶段使用处理器外，还会产生额外的开销以实现并发。因此，虽然收集器的垃圾收集暂停通常比较短暂，但应用程序吞吐量也往往略低于其他收集器
  2. 在具有多处理器的计算机上，处理器在集合的并发部分期间可以用于应用程序线程。因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致暂停时间缩短，但是应用程序的处理器资源也会减少，并且应该会有一些减速
特别是如果应用程序最大限度的使用所有的处理内核，随着N的增加。由于并发垃圾收集器导致的处理器资源的减少变得更小，并且并发收集的益处增。
  3. 因为在并发阶段期间至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器上提供任何帮助，但是，CMS，（不是G1）有一个单独的模式，可以在只有一个或者两个处理器的系统上实现暂停，看到增量模式在并发标记
扫描收集器的详细信息。
  
### Concurrent Mark Sweep (CMS) Collectors

* 并发标记扫描（CMS）收集器转为需要较短垃圾收集暂停且能够给在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计。通常, 具有相对较大的
长寿命的数据集（大型终身产生）并在具有亮哥或更多处理器的机器上运行的应用程序倾向于从该收集器的使用中受益，但是，对于暂停时间要求较低的任何
程序，应考虑使用此收集器。使用命令行选项启用CMS收集器―XX:+UseConcMarkSweepGC。

* 与其他可用收集器雷士，GMS收集器是世代的，英雌，小型和主要收藏都会发生。CMS收集器通过使用单独的垃圾收集器线程在执行应用程序的同时跟踪
可访问对象，尝试减少由于主要收集而导致的暂停时间。在每个主要收集周期中，CMS收集器会在收集开始时暂停所以有应用程序线程，并再次暂停到集合的中间位置，
第二次暂停往往是两次的时间越长，在两个暂停期间，多线程用于执行收集工作。

#### 并发模式失败
  * CMS收集器使用一个或多个应用程序线程同时运行的垃圾收集器线程，目的是在完成之前完成tenured generation 收集。如前所述。在正常操作中，
CMS收集器在应用程序线程仍在运行执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，如果CMS收集器无法在终端生成填满之前完
成对无法访问的对象的回收，或者无法使用tenured generation 中的可用空闲块满足分配。则应用程序将暂停并且收集完成所有应用程序线程都停止了
无法同时完成收集称为**并发模式失败**并指示需要调整CMS收集器参数，如果并发收集被显式垃圾收集（System.gc()）中断或者为诊断工具提供信息所需
垃圾收集，则会报告并发模式中断

#### 过多的GC时间和OutOfMemoryError
  * OutOfMemoryError如果在垃圾收集中话费了太多时间，则CMS收集器会抛出 **如果超过98%的时间用于垃圾收集，并且回收的堆少于2%。 则抛出OutOfMemoryError**
此功能在于防止程序长时间运行，由于堆太小，而很少货没有进度，如果有必要刻意通过向-XX:-UseGCOverheadLimit命令行添加选项来禁用此功能。
  * 该次略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98%的时间限制。换句话说。只有在应用程序停止时执行的集合才会计入过多的GC
时间，此类集合通过是予以并发模式失败或显式收集请求（例如：调用System.gc()）

#### 浮动垃圾
  * 与Java HotSpot VM 中所有其他收集器一样，CMS收集器是一个跟踪收集器，它至少标识堆中的所有访问对象，在Richard Jones 和 Rafael D.Lins
的出版《Garbage Collection: Algorithms for AutoMated Dynamic Memory》中，它是一个增量更新收集器，由于应用程序线程和垃圾收集器线程在
主要集合其他并发运行，因此垃圾收集器线程跟踪的对象可能随后在时间收集过程结束变得不可访问。这些尚未回收的无法到达的物体称为浮动垃圾，浮动垃圾量
取决于并发收集周期的持续时间以及应用程序的参考更新频率（也称为突变）。此外，由于年轻一代和终身代都是独立收集的，因此每一代都是另一方的根源，
作为一个粗略的知道方正，尝试将剩余一袋的规模增加20%来解释浮动垃圾，在下一代的收集在一个并发收集周期结束时堆中的浮动垃圾。
  
#### 暂停
  * CMS 收集器在并发收集周期中暂停2次应用程序，第一个暂停是将根目录中可直接访问的对象，（例如：来自应用程序线程堆栈和寄存器的对象引用，静态对象等）
以及对中的其他信息（例如：年轻代）标记为实时，第第一次暂停被称为**初始标记暂停**，第二个展厅在并发跟踪阶段结束时发现，并且在CMS收集器完成
对该对象的跟踪之后，找到鱼油对象中引用的应用程序线程而导致的并发跟踪遗漏的对象，第二次暂停被称为**备注暂停**。
  
#### 并行阶段
  * 可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。在该并发跟踪阶段期间，一个或多个并发垃圾收集器线程可能正在使用否则该应用程序可用的处理资源。
因此，即使应用程序线程未暂停，计算绑定应用程序也可能在此和其他并发阶段期间看到应用程序吞吐量相应下降。备注暂停后，并发烧苗阶段会收集标识为无法
访问的对象。收集周期完成后，CMS收集器将等待，几乎不消耗任何计算资源，知道下一个主要收集周期开始。

#### 启动并发收集周期
  * 启用串行收集器时， 只要终端生成已满并且在收集完成时停止所有应用程序线程，就会发生主要收集，相反，并发集合的开始必须定时，以便集合可以在
终身代变满之前完成，否则，应用程序会因并发模式故障而观察到更长的暂停，有几种方法可以启动并发收集。

  * 根据最近的历史记录，CMS收集器维护对终生代用尽之前剩余时间的估计以及并发收集周期所需的时间。使用这些动态估计，开始并发收集周期，目的是在
终生代用尽之前完成收集周期。这些估计值是为了安全而填充的，应为并发模式故障可能非常昂贵
  
  * 如果终生代的占用率超过初始占用率（终生代的百分比），则也开始并发收集。此初始占用阈值的默认值约为92%，但该值可能会随发行版本的不同而有所变化
可以使用命令行选项手动调整此值-XX:CMSInitiatingOccupancyFraction=<N>, 其中<N>是tenured generation大小的整数百分比（0到100）。

#### 调度暂停
  * 年轻代收集和终身代收集的停顿独立发生，他们不重叠，但可以快速连续发生，使得来自一个集合的暂停，紧接着来自另一个集合的一个集合，
可以看起来是单个较长的暂停，为了避免这种情况，CMS收集器尝试在上一次和下一次年轻代暂停之间大致中途安排配置暂停，目前商队对初始标记暂停进行
调度，这通常比备注暂停短得多。

#### 增量模式
  * jdk1.8 废弃， 以后版本可能被删除。


### Garbage-First Garbage Collector
  * Garbage-First (G1) 垃圾收集器是一种服务器式垃圾收集器，适用于具有较大内存的多出力机器，它尝试以高概率满足垃圾收集（GC）暂停时间目标，
同时实现高吞吐量。全堆操作（例如：全局标记）与应用程序线程同时执行。这可以方式与堆或实时数据大小成比例的中断。
  
  * G1收集器通过多种技术实现了高新更能和暂停时间目标
  
  * 堆被分区为一组大小相等的堆区域，每个堆区域都是连续的虚拟内存范围。G1执行并发全局标记阶段以确定整个堆中的对象活跃度。在标记阶段，完成后，
G1执行并发全局标记阶段以确定整个堆中对象的活跃度。在标记阶段完成后，G1知道那些区域基本上是空的。它首先收集这些区域。这通常会产生大量的自由空间。
这就是为什么这种垃圾手机方法称为Garbage-First. 顾名思义，G1将被其集合和压缩活动集中在堆的可能填充满可回收对象的区域，即垃圾。G1使用暂停预测
模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择需要手机的区域数。

  * G1将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中压缩并释放内存，这种疏散在多处理器上并行执行。以减少暂停时间并且提高吞吐量。
因此，每次垃圾手机，G1都会不对努力较少碎片，这个超出了以前两种方法的能力，CMS（Concurrent Mark Sweep）垃圾收集不进行压缩，并行压缩仅执行整堆压缩
并行压缩仅执行整堆压缩，这会导致相当长的暂停时间。

  * G1的第一个重点是为运行需要具有有限GC延迟的大堆应用程序的用户提供解决方案，这意味着堆大小约为6GB或更大，并且稳定且可预测的暂停时间
低于0.5秒。
   
  * 如果应用程序具有一下或多个特征，那么今天我们CMS或并行压缩的应用程序将从切换到G1中收益。
    * 超过50%的java堆占用了实时数据。
    * 对象分配率或促销率差异很大
    * 该应用程序正在经历不希望的长垃圾手机或压缩暂停（超过0.5到1秒）

  * G1 计算是作为 Concurrent Mark-Sweep Collector (CMS) 的长期替代品，将G1与CMS进行比较揭示了使G1成为更好解决方案的差异。一个区别是
G1是压缩收集器，此外，G1提供比CMS收集器更可预测的垃圾手机暂停，并允许用户指定所需的暂停目标。

  * 与CMS一样，G1专为需要较短GC暂停的应用而设计。
  
  * G1在逻辑意义上是世代的。一组空区域被指定为逻辑年轻代，在图中，年轻一代是浅蓝色。分配是从那个合乎逻辑的年轻一代完成的。
当年轻一代充满时，那组地区被垃圾收集器（一个年轻的收藏）。在某些情况下，年轻区域以外的区域（深蓝色的旧区域）可以同时进行垃圾收集，
这杯称为混合集合，在该图中，收集的区域用红色框标记。该图描绘了一个混合收藏品，因为正在收集年轻地区和旧地区。垃圾收集是一个压缩集合，它将
活动对象复制到选定的最初为空的区域，基于幸存物体的年龄，可以将物体复制会到幸存区，（标记为 “S”） 或者老年代（未具体标识）
标有“H”的区域包含大于半个区域且经过特殊处理的巨大物体。

#### 分配（疏散）失败
  * 和CMS一样G1收集器在应用程序继续运行时，运行其集合的一部分，并且存在应用程序分配对象的速度快于垃圾收集器，可以恢复可用空间的风险。
在G1中，G1正在将实时数据从一个区域（撤离）复制到另一个区域时发生故障（Java堆耗尽）。进行复制以压缩实时数据。如果在撤离被垃圾收集的区域期间
无法找到空闲（空）区域， 则会发生分配失败（因为没有空间来分配来自撤离区域的活动对象）和停止世界（STW）完整收藏完成。

#### 浮动垃圾
  * 对象可能在G1集合期间死亡而不被收集，G1使用一种名为snapshot-at-the-beginning (SATB) 的技术来保证垃圾收集器找到所有活动对象。
SATB声明，在并发标记开始存在的任何对象（整个堆上的标记）被认为是用集合的目的实时对象，SATB允许浮动垃圾的方式类似于CMS增量更新。

#### 暂停
  * G1暂停应用程序以将活动对象复制到新区域。这些停顿可以是年期代收集停顿。只收集年轻代或混合收集暂停。年轻和年老代撤离。与CMS一样，最终标记或
备注暂停可在应用程序停止时完成标记。虽然CMS也有初始标记暂停，但G1会将初始标记工作作为疏散暂停的一部分，G1在集合的末尾有一个清理阶段，部分是STW
部分是并发的，清理STW部分识别空区域并确定作为下一个集合的候选旧区域。

#### 卡表和并发阶段
  * 如果垃圾收集器不收集整个堆（增量集合），则垃圾收集器需要知道从堆的未收集部分到正在收集的堆的部分中的指针，这通常用于粉黛垃圾收集器，
其中堆中的未收集部分通常是旧代，并且堆的收集部分是年轻代。用于保存此信息的数据结构（旧代指针指向年轻代对象）是一个记忆集。卡表是一个的定类型
的记录位置的， Java HotSpot VM 使用字节数组作为卡表，每个字节称为卡，卡对应于堆中的一系列地址，弄脏卡意味着将字节值更改为脏值，脏值可能包含从卡
的覆盖地址范围内的旧代到年轻代的新指针。
 
#### 启动并发收集周期
  * 如前所述， 年轻代和年老代都是垃圾收集的混合收集，为了收集旧区域，G1堆中活动进行了完整标记，这种标记通过并行标记阶段完成的，当整个Java堆
的占用率达到参数值的时候，将启动并发标记阶段InitiatingHeapOccupancyPercent. 使用命令行选项设置此参数的值
-XX：InitiatingHeapOccupancyPercent=<NN>. 默认值为InitiatingHeapOccupancyPercent=45

#### 暂停时间目标
  * 使用标志设置G1的暂停时间目标MaxGCPauseMillis. G1使用预测模型来确定，在该目标暂停时间内可以弯沉多少垃圾收集工作，在集合的最后，G1选择
要在下一个集合（集合集）中收集的区域。集合集将包含年轻区域（其大小的综合决定了逻辑年轻代的大小）。部分是通过选择集合集中的年轻区域的数量，G1
控制GC暂停的长度。您可以像在其他垃圾收集器中一样在命令行上指定年轻代的大小，但这样做可能会妨碍G1达到目标暂停时间的能力，除了暂停时间目标外，
您还可以指定暂停可以发生的时间段的长度。您可以指定时间跨度的最小mutator使用量（GCPauseIntervalMillis）以及暂停时间目标。默认值为
MaxGCPauseMillis=200毫秒， GCPauseIntervalMillis(0) 的默认值相当于时间跨度上没有要求。

### 参考文档

 * https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/
 * https://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/