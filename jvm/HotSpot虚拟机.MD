###HosSpot虚拟机

#### 简介
* Amdahl定律（给定问题的并行加速受到问题的连续部分的限制）意味着大多数工作负载无法完美并行化; 某些部分始终是顺序的，不会受益于并行性。Java平台也是如此。特别是，Oracle Java 1.4之前的Java平台虚拟机不支持并行垃圾收集，因此垃圾收集对多处理器系统的影响相对于其他并行应用程序而言也在增长。

垃圾收集器cpu中话费的时间百分比

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

* 这表明在小型系统上开发时可忽略不计的速度问题可能成为扩展到大型系统时的主要瓶颈。但是，减少这种瓶颈的微小改进可以在性能上产生很大的提高。对于足够大的系统，选择正确的垃圾收集器并在必要时进行调整是值得的。

### Ergonomics
* 服务器定义 
  * 内核数量大于2
  * 内存大于2G
  将安装 Server VM 版本
  
* 默认参数以及配置
  * 初始堆大小为1/64的物理内存，最大为1GB
  * 最大堆大小为1/4物理内存，最大为1GB
 

### Generations

* 内存模型

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

在初始化的时候，实际上并未分配物理内存，对象存储保留完整地址给空间可分为，年轻代和年老代

  * 堆
     
     * 堆参数说明
        ![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_006_prm_gn_sz.png)
        
     * 堆大小的设置规则
         * 除非遇到暂停问题，尽可能的为虚拟机尽可能的设置更多的内存，默认大小通常太小
         * 通过从虚拟机中删除最终小的大小决策， 设置-Xms和-Xmx相同值可提高可预测性，但是如果做出了糟糕的选择，
    则虚拟机无法进行补偿
         * 通常，增加处理器数量时增加内存，因为分配可以并行化
             
     * 年轻代, 年轻代通过参数NewRatio控制，设置-XX:NewRatio=3意味着，年轻代和年老代之间的比例是1:3
换句话说，伊甸区和幸存区的组合大小将是总堆大小的1/4
     * 幸存区, 幸存区通过参数SurvivorRatio来调整幸存区大小， 这个通常对性能影响不大。例如：-XX:SurvivorRatio=6将伊甸区和幸存区空间比率设置
为6:1,换句话说，每个幸存区空间是伊甸区的六分之一，因此是年轻代的八分之一（不是七分之一，应为有两个幸存区）
     * 

### Available Collectors

* 串行垃圾收集器，适合单处理器机器
  设置 -XX:+UseSerialGC
  
* 并行收集器,默认启用并行压缩。设置-XX:+UserParallelGC

* 大中型数据采集程序
  CMS收集器 -XX:+UseConcMarkSweepGC;
  G1收集器 -XX:+UseG1GC
  
* 选择垃圾回收器
  * 程序具有较小的数据集（100MB）选择-XX:+UseSerialGC
  * 如果单个处理器上运行且没有暂停时间要求，则让VM选择收集器，或者选择带有该选项的串行收集器-XX:+UseSerialGC
  * 如果（a）峰值应用程序是第一优先级并且（b）没有暂停时间要求或1秒或更长的暂停时间可以接受，那么选择-XX:+UseParallelGC
  * 如果响应时间比总吞吐量更重要，并且垃圾收集暂停必须保存短于大约1秒，则使用-XX:+UseConcMarkSweepGC 或者选择并发收集器 -XX:+UseG1GC

说明：
-Xms 表示Java虚拟机堆初始内存分配大小
-Xmx 表示Java虚拟机堆内存可分配的最大上限


### The Parallel Collector
* 并行收集器，也称为吞吐量收集器，是类似于串行收集器的分代收集器，主要区别于**多线程用于加速垃圾收集器**。默认情况下， 
使用此选项，并行执行次要和主要集合，进一步减少垃圾收集开销。

* 默认情况下，在服务器级计算机选择并行收集器。此外，并行收集器使用自动调整方法，允许您指定特定行为，而不是生成大小和其他低优先级
我们可以指定最大垃圾收集暂停时间，吞吐量和占用时间。
  * 最大垃圾收集暂停时间：使用命令行选项指定-XX:MaxGCPauseMillis=<N>，
  * 吞吐量：吞吐量目标是根据垃圾回收话费的时间之外说话费的时间来衡量的。命令行选项。-XX:GCTimeRatio=<N> 设置垃圾收集时间与应用程序时间的比率
1/(1 + <N>)。 例如，-XX:GCTimeRatio=19将目标设置为垃圾收集总时间的 1/20或1/5， 默认值为99，导致垃圾回收的时间为1%
  * FootPrint：最大堆内存设置使用-Xmx<N>, 此外，只要满足其他目标，收集器就可以隐含的目标，即最小堆大小。

* 设置参数的优先级
  * 最大暂停时间目标
  * 吞吐量目标
  * 最小足迹目标
  
* 默认堆大小。如果不指定，默认是根据计算机内存大小来计算的。
* 客户端JVM默认初始值和最大堆大小
  * 默认的最大堆大小是物理内存的一半，直到物理内存大小为192MB， 否者为物理内存的四分之一，物理内存大小为1GB
   例如：计算机的物理内存为128MB， 那么最大堆大小为64MB, 当等于1GM的时候，最大堆大小为256MB
  * 除非程序创建足够的对象来需要，否则JVM实际上不会使用最大堆大小，在JVM初始化期间分配一个小得多的数量，称为初始堆大小，此数量最小为8MB，
否则为物理内存的1/64,最大物理内存大小为1GB。分配给年前代的最大空间量是总堆大小的1/3。

* 服务器JVM默认初始和最大堆大小
  * 默认的初始和最大堆大小在服务器JVM上的工作方式和客户端JVM的大小相同，只是默认值更高。32位操作系统4G或者更多物理内存，默认最大堆大小可以达到1GB
在64位JVM上，如果128GB，默认堆大小最多可以达到32GB。 

* OOM 是由于GC回收时间过长导致 OutOfMemoryError
  1. 并行垃圾回收器抛出OOM的条件： 垃圾收集器中话费了超过98%的总时间并且回收不了2%的堆。
  2. 处理方案如果为了防止程序运行时间过长，同时堆太小没有进度可以通过添加 -XX:-UseGCOverheadLimit
  
### The Mostly Concurrent Collectors
* 常见的垃圾回收器
  * Concurrent Mark Sweep (SMS) Collector SMS 收集器， 垃圾回收器适合较短的垃圾收集暂停可以与垃圾收集共享处理器资源的应用程序。
  * Garbage-First Garbage Collector  G1 收集器，适用于大内存服务器，它高概率满足垃圾回收器暂停时间目标，同时实现高吞吐量。

* 并发的开销
  1. 大多数并发收集器交互处理器资源，以缩短收集暂停时间。  最明显的开销就是在集合的并发部分期间使用一个或者多个处理器，在N处理系统上，结合的并发部分将使用处理器的KIN， 其中1<= k <= ceiling{1/4}.
（注意K的精确选择和界限可能会发生变化）除了在并发阶段使用处理器外，还会产生额外的开销以实现并发。因此，虽然收集器的垃圾收集暂停通常比较短暂，但应用程序吞吐量也往往略低于其他收集器
  2. 在具有多处理器的计算机上，处理器在集合的并发部分期间可以用于应用程序线程。因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致暂停时间缩短，但是应用程序的处理器资源也会减少，并且应该会有一些减速
特别是如果应用程序最大限度的使用所有的处理内核，随着N的增加。由于并发垃圾收集器导致的处理器资源的减少变得更小，并且并发收集的益处增。
  3. 因为在并发阶段期间至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器上提供任何帮助，但是，CMS，（不是G1）有一个单独的模式，可以在只有一个或者两个处理器的系统上实现暂停，看到增量模式在并发标记
扫描收集器的详细信息。
  
### Concurrent Mark Sweep (CMS) Collectors

* 并发标记扫描（CMS）收集器转为需要较短垃圾收集暂停且能够给在应用程序运行时与垃圾收集器共享处理器资源的应用程序而设计。通常, 具有相对较大的
长寿命的数据集（大型终身产生）并在具有亮哥或更多处理器的机器上运行的应用程序倾向于从该收集器的使用中受益，但是，对于暂停时间要求较低的任何
程序，应考虑使用此收集器。使用命令行选项启用CMS收集器―XX:+UseConcMarkSweepGC。

* 与其他可用收集器雷士，GMS收集器是世代的，英雌，小型和主要收藏都会发生。CMS收集器通过使用单独的垃圾收集器线程在执行应用程序的同时跟踪
可访问对象，尝试减少由于主要收集而导致的暂停时间。在每个主要收集周期中，CMS收集器会在收集开始时暂停所以有应用程序线程，并再次暂停到集合的中间位置，
第二次暂停往往是两次的时间越长，在两个暂停期间，多线程用于执行收集工作。

#### 并发模式失败
  * CMS收集器使用一个或多个应用程序线程同时运行的垃圾收集器线程，目的是在完成之前完成tenured generation 收集。如前所述。在正常操作中，
CMS收集器在应用程序线程仍在运行执行大部分跟踪和扫描工作，因此应用程序线程只能看到短暂的暂停。但是，如果CMS收集器无法在终端生成填满之前完
成对无法访问的对象的回收，或者无法使用tenured generation 中的可用空闲块满足分配。则应用程序将暂停并且收集完成所有应用程序线程都停止了
无法同时完成收集称为**并发模式失败**并指示需要调整CMS收集器参数，如果并发收集被显式垃圾收集（System.gc()）中断或者为诊断工具提供信息所需
垃圾收集，则会报告并发模式中断

#### 过多的GC时间和OutOfMemoryError
  * OutOfMemoryError如果在垃圾收集中话费了太多时间，则CMS收集器会抛出 **如果超过98%的时间用于垃圾收集，并且回收的堆少于2%。 则抛出OutOfMemoryError**
此功能在于防止程序长时间运行，由于堆太小，而很少货没有进度，如果有必要刻意通过向-XX:-UseGCOverheadLimit命令行添加选项来禁用此功能。
  * 该次略与并行收集器中的策略相同，只是执行并发收集所花费的时间不计入98%的时间限制。换句话说。只有在应用程序停止时执行的集合才会计入过多的GC
时间，此类集合通过是予以并发模式失败或显式收集请求（例如：调用System.gc()）

#### 浮动垃圾
  * 与Java HotSpot VM 中所有其他收集器一样，CMS收集器是一个跟踪收集器，它至少标识堆中的所有访问对象，在Richard Jones 和 Rafael D.Lins
的出版《Garbage Collection: Algorithms for AutoMated Dynamic Memory》中，它是一个增量更新收集器，由于应用程序线程和垃圾收集器线程在
主要集合其他并发运行，因此垃圾收集器线程跟踪的对象可能随后在时间收集过程结束变得不可访问。这些尚未回收的无法到达的物体称为浮动垃圾，浮动垃圾量
取决于并发收集周期的持续时间以及应用程序的参考更新频率（也称为突变）。此外，由于年轻一代和终身代都是独立收集的，因此每一代都是另一方的根源，
作为一个粗略的知道方正，尝试将剩余一袋的规模增加20%来解释浮动垃圾，在下一代的收集在一个并发收集周期结束时堆中的浮动垃圾。
  
#### 暂停
  * CMS 收集器在并发收集周期中暂停2次应用程序，第一个暂停是将根目录中可直接访问的对象，（例如：来自应用程序线程堆栈和寄存器的对象引用，静态对象等）
以及对中的其他信息（例如：年轻代）标记为实时，第第一次暂停被称为**初始标记暂停**，第二个展厅在并发跟踪阶段结束时发现，并且在CMS收集器完成
对该对象的跟踪之后，找到鱼油对象中引用的应用程序线程而导致的并发跟踪遗漏的对象，第二次暂停被称为**备注暂停**。
  
#### 并行阶段
  * 可达对象图的并发跟踪发生在初始标记暂停和备注暂停之间。在该并发跟踪阶段期间，一个或多个并发垃圾收集器线程可能正在使用否则该应用程序可用的处理资源。
因此，即使应用程序线程未暂停，计算绑定应用程序也可能在此和其他并发阶段期间看到应用程序吞吐量相应下降。备注暂停后，并发烧苗阶段会收集标识为无法
访问的对象。收集周期完成后，CMS收集器将等待，几乎不消耗任何计算资源，知道下一个主要收集周期开始。

#### 启动并发收集周期
  * 启用串行收集器时， 只要终端生成已满并且在收集完成时停止所有应用程序线程，就会发生主要收集，相反，并发集合的开始必须定时，以便集合可以在
终身代变满之前完成，否则，应用程序会因并发模式故障而观察到更长的暂停，有几种方法可以启动并发收集。

  * 根据最近的历史记录，CMS收集器维护对终生代用尽之前剩余时间的估计以及并发收集周期所需的时间。使用这些动态估计，开始并发收集周期，目的是在
终生代用尽之前完成收集周期。这些估计值是为了安全而填充的，应为并发模式故障可能非常昂贵
  
  * 如果终生代的占用率超过初始占用率（终生代的百分比），则也开始并发收集。此初始占用阈值的默认值约为92%，但该值可能会随发行版本的不同而有所变化
可以使用命令行选项手动调整此值-XX:CMSInitiatingOccupancyFraction=<N>, 其中<N>是tenured generation大小的整数百分比（0到100）。

#### 调度暂停
  * 年轻代收集和终身代收集的停顿独立发生，他们不重叠，但可以快速连续发生，使得来自一个集合的暂停，紧接着来自另一个集合的一个集合，
可以看起来是单个较长的暂停，为了避免这种情况，CMS收集器尝试在上一次和下一次年轻代暂停之间大致中途安排配置暂停，目前商队对初始标记暂停进行
调度，这通常比备注暂停短得多。

#### 增量模式
  * jdk1.8 废弃， 以后版本可能被删除。


### Garbage-First Garbage Collector



### 参考文档

 * https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/