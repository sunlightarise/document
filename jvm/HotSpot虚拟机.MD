###HosSpot虚拟机

#### 简介
* Amdahl定律（给定问题的并行加速受到问题的连续部分的限制）意味着大多数工作负载无法完美并行化; 某些部分始终是顺序的，不会受益于并行性。Java平台也是如此。特别是，Oracle Java 1.4之前的Java平台虚拟机不支持并行垃圾收集，因此垃圾收集对多处理器系统的影响相对于其他并行应用程序而言也在增长。

垃圾收集器cpu中话费的时间百分比

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

* 这表明在小型系统上开发时可忽略不计的速度问题可能成为扩展到大型系统时的主要瓶颈。但是，减少这种瓶颈的微小改进可以在性能上产生很大的提高。对于足够大的系统，选择正确的垃圾收集器并在必要时进行调整是值得的。

### Ergonomics
* 服务器定义 
  * 内核数量大于2
  * 内存大于2G
  将安装 Server VM 版本
  
* 默认参数以及配置
  * 初始堆大小为1/64的物理内存，最大为1GB
  * 最大堆大小为1/4物理内存，最大为1GB
 

### Generations

* 内存模型

![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

在初始化的时候，实际上并未分配物理内存，对象存储保留完整地址给空间可分为，年轻代和年老代

  * 堆
     
     * 堆参数说明
        ![avatar](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_006_prm_gn_sz.png)
        
     * 堆大小的设置规则
         * 除非遇到暂停问题，尽可能的为虚拟机尽可能的设置更多的内存，默认大小通常太小
         * 通过从虚拟机中删除最终小的大小决策， 设置-Xms和-Xmx相同值可提高可预测性，但是如果做出了糟糕的选择，
    则虚拟机无法进行补偿
         * 通常，增加处理器数量时增加内存，因为分配可以并行化
             
     * 年轻代, 年轻代通过参数NewRatio控制，设置-XX:NewRatio=3意味着，年轻代和年老代之间的比例是1:3
换句话说，伊甸区和幸存区的组合大小将是总堆大小的1/4
     * 幸存区, 幸存区通过参数SurvivorRatio来调整幸存区大小， 这个通常对性能影响不大。例如：-XX:SurvivorRatio=6将伊甸区和幸存区空间比率设置
为6:1,换句话说，每个幸存区空间是伊甸区的六分之一，因此是年轻代的八分之一（不是七分之一，应为有两个幸存区）
     * 

### Available Collectors

* 串行垃圾收集器，适合单处理器机器
  设置 -XX:+UseSerialGC
  
* 并行收集器,默认启用并行压缩。设置-XX:+UserParallelGC

* 大中型数据采集程序
  CMS收集器 -XX:+UseConcMarkSweepGC;
  G1收集器 -XX:+UseG1GC
  
* 选择垃圾回收器
  * 程序具有较小的数据集（100MB）选择-XX:+UseSerialGC
  * 如果单个处理器上运行且没有暂停时间要求，则让VM选择收集器，或者选择带有该选项的串行收集器-XX:+UseSerialGC
  * 如果（a）峰值应用程序是第一优先级并且（b）没有暂停时间要求或1秒或更长的暂停时间可以接受，那么选择-XX:+UseParallelGC
  * 如果响应时间比总吞吐量更重要，并且垃圾收集暂停必须保存短于大约1秒，则使用-XX:+UseConcMarkSweepGC 或者选择并发收集器 -XX:+UseG1GC

说明：
-Xms 表示Java虚拟机堆初始内存分配大小
-Xmx 表示Java虚拟机堆内存可分配的最大上限


### The Parallel Collector
* 并行收集器，也称为吞吐量收集器，是类似于串行收集器的分代收集器，主要区别于**多线程用于加速垃圾收集器**。默认情况下， 
使用此选项，并行执行次要和主要集合，进一步减少垃圾收集开销。

* 默认情况下，在服务器级计算机选择并行收集器。此外，并行收集器使用自动调整方法，允许您指定特定行为，而不是生成大小和其他低优先级
我们可以指定最大垃圾收集暂停时间，吞吐量和占用时间。
  * 最大垃圾收集暂停时间：使用命令行选项指定-XX:MaxGCPauseMillis=<N>，
  * 吞吐量：吞吐量目标是根据垃圾回收话费的时间之外说话费的时间来衡量的。命令行选项。-XX:GCTimeRatio=<N> 设置垃圾收集时间与应用程序时间的比率
1/(1 + <N>)。 例如，-XX:GCTimeRatio=19将目标设置为垃圾收集总时间的 1/20或1/5， 默认值为99，导致垃圾回收的时间为1%
  * FootPrint：最大堆内存设置使用-Xmx<N>, 此外，只要满足其他目标，收集器就可以隐含的目标，即最小堆大小。

* 设置参数的优先级
  * 最大暂停时间目标
  * 吞吐量目标
  * 最小足迹目标
  
* 默认堆大小。如果不指定，默认是根据计算机内存大小来计算的。
* 客户端JVM默认初始值和最大堆大小
  * 默认的最大堆大小是物理内存的一半，直到物理内存大小为192MB， 否者为物理内存的四分之一，物理内存大小为1GB
   例如：计算机的物理内存为128MB， 那么最大堆大小为64MB, 当等于1GM的时候，最大堆大小为256MB
  * 除非程序创建足够的对象来需要，否则JVM实际上不会使用最大堆大小，在JVM初始化期间分配一个小得多的数量，称为初始堆大小，此数量最小为8MB，
否则为物理内存的1/64,最大物理内存大小为1GB。分配给年前代的最大空间量是总堆大小的1/3。

* 服务器JVM默认初始和最大堆大小
  * 默认的初始和最大堆大小在服务器JVM上的工作方式和客户端JVM的大小相同，只是默认值更高。32位操作系统4G或者更多物理内存，默认最大堆大小可以达到1GB
在64位JVM上，如果128GB，默认堆大小最多可以达到32GB。 

* OOM 是由于GC回收时间过长导致 OutOfMemoryError
  1. 并行垃圾回收器抛出OOM的条件： 垃圾收集器中话费了超过98%的总时间并且回收不了2%的堆。
  2. 处理方案如果为了防止程序运行时间过长，同时堆太小没有进度可以通过添加 -XX:-UseGCOverheadLimit
  
### The Mostly Concurrent Collectors
* 常见的垃圾回收器
  * Concurrent Mark Sweep (SMS) Collector SMS 收集器， 垃圾回收器适合较短的垃圾收集暂停可以与垃圾收集共享处理器资源的应用程序。
  * Garbage-First Garbage Collector  G1 收集器，适用于大内存服务器，它高概率满足垃圾回收器暂停时间目标，同时实现高吞吐量。

* 并发的开销
  1. 大多数并发收集器交互处理器资源，以缩短收集暂停时间。  最明显的开销就是在集合的并发部分期间使用一个或者多个处理器，在N处理系统上，结合的并发部分将使用处理器的KIN， 其中1<= k <= ceiling{1/4}.
（注意K的精确选择和界限可能会发生变化）除了在并发阶段使用处理器外，还会产生额外的开销以实现并发。因此，虽然收集器的垃圾收集暂停通常比较短暂，但应用程序吞吐量也往往略低于其他收集器
  2. 在具有多处理器的计算机上，处理器在集合的并发部分期间可以用于应用程序线程。因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致暂停时间缩短，但是应用程序的处理器资源也会减少，并且应该会有一些减速
特别是如果应用程序最大限度的使用所有的处理内核，随着N的增加。由于并发垃圾收集器导致的处理器资源的减少变得更小，并且并发收集的益处增。
  3. 因为在并发阶段期间至少有一个处理器用于垃圾收集，所以并发收集器通常不会在单处理器上提供任何帮助，但是，CMS，（不是G1）有一个单独的模式，可以在只有一个或者两个处理器的系统上实现暂停，看到增量模式在并发标记
扫描收集器的详细信息。
  
### Concurrent Mark Sweep (CMS) Collectors