### 类加载器
* 类的加载的最终产品是位于内存中的class对象
* Class对象封装了类在方法区内的数据结构并且向Java程序员提供了访问方法区内的数据结构的接口
* 类加载器用来把类记载到Java虚拟机中。从jdk1.2开始

#### 类的加载详细描述
* 加载：把二进制形式的Java类型读入到Java虚拟机中
* 验证：
  * 准备：为类变量分配内存，设置默认值，但是在到达初始化之前，类变量都没有初始化为真正的初始值
  * 解析：解析过程就是在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程  
* 初始化：为类变量赋予正确的初始值
* 类实例化；
  * 为新的对象分配内存
  * 为实例变量赋默认值
  * 为实例变量赋正确的初始值
  * Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为"<init>".
针对源代码中每一个类的构造方法，Java编译器都产生一个"<init>"方法

### 类加载器分类
* Java 虚拟机自带的加载器
  * 根类加载器（Bootstrap）       ==>（Load JRE\lib\rt.jar 或 -Xbootclasspaht 选项所指定的jar包）
  * 拓展类加载器（Extension）     ==>（Load JRE\ext\*.jar 或 -Djava.ext.dirs 选项所指定目录下的类和jar包）
  * 系统（应用）类加载器（System） ==>（Load CLASSPATH 或 -Djava.class.path 所指定的目录下的类和jar包）
* 用户自定义的类加载器
  * java.lang.ClassLoader的子类  ==> 通过 java.lang.ClassLoader的子类自定义加载class
  * 用户可以定制类的加载方式。
  
### 类的加载
* 类加载器在不需要这个"类被首次主动使用"的时候加载它
* JVM 规范允许类加载器在预料某个类将要被使用的时候就预先加载他，如果在预先加载的过程中遇到了.class文件缺失或存在错误
类加载器必须在**程序首次主动**使用该类时才报告错误（**LinkageError**错误）。
* 如果这个类一直没有被程序主动使用，那么**类加载器就不会被报告错误**。

### 类的验证
* 类被加载后，就进入了连接阶段。连接就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
* 类验证的内容：
  * 类文件的结构检查
  * 语义检查
  * 字节码检查
  * 而精致兼容性的验证
  
#### 在准备阶段
* 类初始化步骤
  * 如果这个类还没有被加载和连接。那就先进行记载和连接。
  * 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类。
  * 加入类中存在初始化语句，那就一次执行这些初始化语句。
 
### 类的初始化时机
* 主动使用（七种，**重要**）
  * 创建类的实例
  * 访问某个类或接口的静态变量，或者对该静态变量赋值
  * 调用类的静态方法
  * 反射（如 Class.forName("com.test.Test")
  * 初始化一个类的子类
  * Java虚拟机启动时被标记为启动类的类（Java Test）
* 类的初始化时机
  * JDK1.7开始提供的动态语言支持，java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic,
REF_invokeStatic句柄对应的类没有被初始化则初始化。
* 当Java虚拟机初始化一个类时，要求它所有的父类都被初始化，单这一条规则并不适用于接口。
  * 在初始化一个类时，并不会先初始化它所实现的接口
  * 在初始化一个接口时，并不会先初始化它的父类接口
  * 因此，一个父接口并不会因为他的子接口或者实现了类的初始化而初始化，只有当程序首次被使用特定接口的静态变量时，才会导致该接口的初始化。

* 只有当前程序访问的静态变量或静态方法确实在当前类或当前接口定义时，才可认为是对接口或类的主动使用。

* 调用ClassLoader类的loadClass方法加载一类，并不是对类的主动使用，不会导致类的初始化。

### 类加载器
* 类加载器用来把类加载到Java虚拟机中，从JDK1.2版本开始，类的加载过程采用双亲委托机制，这种机制能够更好的保证Java平台的安全，在此委托机制中，除了
Java虚拟机自带的根类加载器外，其余的类加载器都只有一个父类加载器，当Java程序请求loader1加载Sample类时，loader1首先委托自己的父类区间Sample类
若父类能加载，则由父类完成加载任务，否则才由加载器loader1 加载Sample类。
  * Bootstrap 根类加载器
  * Extension 拓展类加载器
  * System 系统类加载器

### 类的初始化
* Java虚拟机初始化一个类的时候，要求它所有父类都已经被初始化，但是这条规则不适用于接口。
  * 在初始化一个类时，并不会先初始化它所实现的接口
  * 在初始一个接口时，并不会先初始化他的父接口
因此，一个父接口口并不会因为他的子接口或者实现类的初始化而初始化，只有当程首次使用特定解耦的静态变量时，
才会导致该接口的初始化。

### 类的初始化时机
* 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会调至类的初始化。

### 类加载器的双亲委托机制
* 在双亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余类加载器都有且只有一个父加载器



### 注意：
  调用ClassLoader类的loadClass方法，并不是对类的主动使用，不会导致类的初始化
  
  
### 获得ClassLoader的途径
  * 获得当前类的ClassLoader  
    clazz.getClassLoader()
  * 获得当前线程上下文中的ClassLoader  
    Thread.currentThread().getContextClassLoader()
  * 获得系统的ClassLoader  
    ClassLoader.getSystemClassLoader() 
  * 获得调用者的ClassLoader  
    DriverManager.getCallerClassLoader()  