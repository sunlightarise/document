### G1 Garbage First Collector （G1）

* 吞吐量
  * 吞吐量关注的是，在一个指定的时间内，最大化一个应用工作量。
  * 如下方式来衡量一个系统的吞吐量的好坏；
    * 在一个小时内一个事务（或者任务、请求）完成的次数（TPS）
    * 数据库一个小时可以完成多少次查询
  * 关于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单词快速的响应并不值得考虑。

* 响应能力
  * 响应能力是指一个程序或者系统对请求是否能够及时响应，比如：
    * 一个桌面UI能够多快地响应一个事件
    * 一个网站能够多快返回一个页面请求
    * 数据库能够多快返回查询的数据
  * 对于这类对响应能力灵敏的场景，长时间的的停顿是无法接受的。
  
### G1 Garbage Collector
* G1 收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。
* 它满足短时间GC停顿的同时达到一个较高的吞吐量。
* JDK7 以上版本适用。

### G1 收集器的设计目标
* 与应用线程同时工作，几乎不需要 stop the world（与CMS类似）
* 整理剩余空间，不产生内存碎片（CMS只能在Full GC时， 用Stop the World 整理内存碎片）
* GC停顿更加可控
* 不牺牲系统的吞吐量
* GC不要求额外的内存空间（CMS 需要预留空间存储**浮动垃圾**） 
  * 浮动垃圾，并发清理阶段用户线程还在运行，这段时间可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等待下一次GC，这些垃圾称为"浮动垃圾"
* **G1的设计规划是替换掉CMS**
  * G1在某些方面弥补了CMS的一些不足， 比如，CMS使用的是**mark-sweep算法**，自然会产生内存碎片；然而G1基于**copying算法**，高效的整理剩余内存，
  而不是需要管理内存碎片
  * 另外，G1提供了更多的手段，已达到堆GC停顿时间的可控。
  
### Hotspot 虚拟机主要构成
![avatar](../../images/jvm/gc/6.PNG)

### 传统垃圾收集器堆内存结构
![avatar](../../images/jvm/gc/Hotspot_Heap_Structure.PNG)

### G1收集器堆结构
![avatar](../../images/jvm/gc/G1_Heap_Alloction.PNG)

* 特点
  * Heap 被划分为一个个相等的不连续的内存区域（regions）,每个region 都由一个分代的角色：eden、survivor、old
  * 堆每一个角色的数量没有强制的现拟定，也就是说对每一种分代内存的打下，可以动态的变化。
  * G1 最大的特点就是高效的执行回收，优先去执行哪些大量独享可回收的区域（region）

* 堆结构
  * G1使用了GC停顿可预测的模型，来满足用户设定的GC停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，
  一次清除多少个region 
  * G1从多个region中复制存活的对象，点燃后几种放入了一个region中，同时整理、清除内存（copying 收集算法） 
  
### G1 vs CMS
* 对比使用mark-sweep 的CMS，G1使用的copying 算法不会造成内存碎片
* 对比 Parallel Scavenge (基于 copying)、Parallel Old 收集器（基于 mark-compact-sweep）, Parallel会对
整个区域做整理导致GC停顿会比较长，而G1只是特定地这你一个Region

### G1 重要概念
* 分区（Region）: G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题--G1将**整个堆**分成相同大小的分区（Region）
* 每一个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，**称为逻辑上的概念**，这样方便复用
之前分代框架的逻辑。
* 在物理上不需要连续，则带来了额外的好处--有的分区内垃圾对象特别多，有的分区内垃圾对象很少，**G1会优先回收垃圾对象特别多的分区**，
这样可以花费较少的时间来回收这些分区的垃圾，则也就是G1名字的来由，即首先手机垃圾最多的分区。
* 依然会在新生代满了的时候，堆整个新生代进行回收--整个新生代中的对象，要么被回收、要么被晋升，至于新生代也采取分区机制的原因，**则是应为这样跟老年代
  的策略统一，方便调整代的大小**
* G1 还是一种带压缩的的收集器，在回收老年代的分区时，时将存活的对象从一个分区拷贝到另一个可用的分区，这个拷贝的过程实现了局部的压缩。

* **收集集合（CSet）**： 一组被回收的分区的集合。在CSet中存活的数据会在GC过程中被一动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间、
或者老年代

* **已记忆集合（RSet）**：RSet 记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于
垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。
  * Region1 和 Region3 中的独享都引用了Region2 中的独享，因此在Region2 和RSet中记录了这个引用
  ![avatar](../../images/jvm/gc/G1_Region_RSet.PNG)
* G1 GC是在points-out 和card table 之上再加上一层结构来构成points-into RSet: 每一个Region会记录下到底哪些逼得Region有只想自己的指针
而这些指针分别在哪些card范围内。
* 这个RSet其实是一个**hash table**, key是别的region的起始地址，value是一个集合，里面的元素是card table 的index. 举例来说，
如果Region A 的 RSet里有一项key是region B, value里有index为1234的card, 它的意思就是Region B的一个card 里有引用只想Region A。所以
对 Region A来说，该RSet记录的是points-info 的关系；而card table任然记录了points-out的关系

* Snapshot-At-The-Beginning (SATB) SATB 是G1 GC在并发标记阶段使用的增量式的标记算法。
* 并发标记是并发多线程的，但是并发线程在同一个时刻只能扫描一个分区



