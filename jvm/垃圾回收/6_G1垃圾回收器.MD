### G1 Garbage First Collector （G1）

* 吞吐量
  * 吞吐量关注的是，在一个指定的时间内，最大化一个应用工作量。
  * 如下方式来衡量一个系统的吞吐量的好坏；
    * 在一个小时内一个事务（或者任务、请求）完成的次数（TPS）
    * 数据库一个小时可以完成多少次查询
  * 关于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，单词快速的响应并不值得考虑。

* 响应能力
  * 响应能力是指一个程序或者系统对请求是否能够及时响应，比如：
    * 一个桌面UI能够多快地响应一个事件
    * 一个网站能够多快返回一个页面请求
    * 数据库能够多快返回查询的数据
  * 对于这类对响应能力灵敏的场景，长时间的的停顿是无法接受的。
  
### G1 Garbage Collector
* G1 收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统。
* 它满足短时间GC停顿的同时达到一个较高的吞吐量。
* JDK7 以上版本适用。

### G1 收集器的设计目标
* 与应用线程同时工作，几乎不需要 stop the world（与CMS类似）
* 整理剩余空间，不产生内存碎片（CMS只能在Full GC时， 用Stop the World 整理内存碎片）
* GC停顿更加可控
* 不牺牲系统的吞吐量
* GC不要求额外的内存空间（CMS 需要预留空间存储**浮动垃圾**） 
  * 浮动垃圾，并发清理阶段用户线程还在运行，这段时间可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等待下一次GC，这些垃圾称为"浮动垃圾"
* **G1的设计规划是替换掉CMS**
  * G1在某些方面弥补了CMS的一些不足， 比如，CMS使用的是**mark-sweep算法**，自然会产生内存碎片；然而G1基于**copying算法**，高效的整理剩余内存，
  而不是需要管理内存碎片
  * 另外，G1提供了更多的手段，已达到堆GC停顿时间的可控。
  
### Hotspot 虚拟机主要构成
![avatar](../../images/jvm/gc/6.PNG)

### 传统垃圾收集器堆内存结构
![avatar](../../images/jvm/gc/Hotspot_Heap_Structure.PNG)

### G1收集器堆结构
![avatar](../../images/jvm/gc/G1_Heap_Alloction.PNG)

* 特点
  * Heap 被划分为一个个相等的不连续的内存区域（regions）,每个region 都由一个分代的角色：eden、survivor、old
  * 堆每一个角色的数量没有强制的现拟定，也就是说对每一种分代内存的打下，可以动态的变化。
  * G1 最大的特点就是高效的执行回收，优先去执行哪些大量独享可回收的区域（region）

* 堆结构
  * G1使用了GC停顿可预测的模型，来满足用户设定的GC停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，
  一次清除多少个region 
  * G1从多个region中复制存活的对象，点燃后几种放入了一个region中，同时整理、清除内存（copying 收集算法） 
  
### G1 vs CMS
* 对比使用mark-sweep 的CMS，G1使用的copying 算法不会造成内存碎片
* 对比 Parallel Scavenge (基于 copying)、Parallel Old 收集器（基于 mark-compact-sweep）, Parallel会对
整个区域做整理导致GC停顿会比较长，而G1只是特定地这你一个Region

### G1 重要概念
* 分区（Region）: G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题--G1将**整个堆**分成相同大小的分区（Region）
* 每一个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，**称为逻辑上的概念**，这样方便复用
之前分代框架的逻辑。
* 在物理上不需要连续，则带来了额外的好处--有的分区内垃圾对象特别多，有的分区内垃圾对象很少，**G1会优先回收垃圾对象特别多的分区**，
这样可以花费较少的时间来回收这些分区的垃圾，则也就是G1名字的来由，即首先手机垃圾最多的分区。
* 依然会在新生代满了的时候，堆整个新生代进行回收--整个新生代中的对象，要么被回收、要么被晋升，至于新生代也采取分区机制的原因，**则是应为这样跟老年代
  的策略统一，方便调整代的大小**
* G1 还是一种带压缩的的收集器，在回收老年代的分区时，时将存活的对象从一个分区拷贝到另一个可用的分区，这个拷贝的过程实现了局部的压缩。

* **收集集合（CSet）**： 一组被回收的分区的集合。在CSet中存活的数据会在GC过程中被一动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间、
或者老年代

* **已记忆集合（RSet）**：RSet 记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于
垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。
  * Region1 和 Region3 中的独享都引用了Region2 中的独享，因此在Region2 和RSet中记录了这个引用
  ![avatar](../../images/jvm/gc/G1_Region_RSet.PNG)
* G1 GC是在points-out 和card table 之上再加上一层结构来构成points-into RSet: 每一个Region会记录下到底哪些逼得Region有只想自己的指针
而这些指针分别在哪些card范围内。
* 这个RSet其实是一个**hash table**, key是别的region的起始地址，value是一个集合，里面的元素是card table 的index. 举例来说，
如果Region A 的 RSet里有一项key是region B, value里有index为1234的card, 它的意思就是Region B的一个card 里有引用只想Region A。所以
对 Region A来说，该RSet记录的是points-info 的关系；而card table任然记录了points-out的关系

* Snapshot-At-The-Beginning (SATB) SATB 是G1 GC在并发标记阶段使用的增量式的标记算法。
* 并发标记是并发多线程的，但是并发线程在同一个时刻只能扫描一个分区 

### 官方文档

* 地址: https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html

### G1相对CMS的优势
* G1在压缩空间方面是有优势的
* G1通过将内存空间分成区域（Region）的方式变内存碎片的问题
* Eden、Survivor、 Old区不在固定，在内存使用效率上来说是更加灵活
* G1 可以通过设置预期停顿时间（Pause Time）来控制收集时间，避免应用雪崩现象。
* G1 在回收内存后回马上同时合并空间内存的工作，而CMS默认是在STW（stop the world）的时候
* G1 会在Young GC中使用，而CMS只能在Old区使用

### G1 的适合场景
* 服务端多核CPU、JVM内存占用较大的应用
* 应用在运行过程汇总会产生大量内存碎片、需要经常压缩空间
* 想要更可控、可预期的GC停顿周期；预防高并发应用下的雪崩现象

### G1 GC的模式
* G1提供了两种GC模式: Young GC和Mixed GC, 两种都是完全Stop The World的
* Young GC: 选定所有年轻代里的Region。通过控制年假你清代的Region个数，即年轻代内存大小，来控制Young GC的时间开销。
* Mixed GC: 选定所有年轻代里的Region。外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的
开销目标范围内尽可能选择收益高的老年代Region。
* Mixed GC: 不是Full GC, **它只能回收部分老年代Region**， 如果Mixed GC实现在无法跟上程序程序分配内存速度，导致老年代填满无法继续进行Mixed GC,
就会使用Serial Old GC(Full GC) 来收集整个GC heap **所以本质上， G1是不提供Full GC的**。

### global concurrent marking
* global concurrent marking 的执行过程类似于 CMS，但是不同的是，在G1 GC中它**主要是为Mixed GC提供标记服务**，并不是一次GC过程的一个必须环节。
* global concurrent marking 的执行过程分为四个步骤：
  * **初始标记（initial mark, STW）**: 它标记了从GC Root开始直接可达的对象
  * **并发标记（Concurrent Marking）**: 这个阶段从GC Root开始对heap 中的对象进行标记，标记线程与应用程序线程并发执行，并且收集各个Region存活对象
  信息。
  * **重新标记（Remark, STW）**: 标记哪些在并发标记阶段发生变化的对象，将被回收。
  * **清理（Cleanup）**: 清理空Region（没有存活对象的），加入到free list.
  
  * 第一个阶段 initial mark 是共用了Young GC 的暂停，这是因为他们可以服用root scan操作，所以可以说 global concurrent marking 是伴随
  Young GC而发生的。
  * 第四阶段 Cleanup 只是回收了没有粗活对象的Region，所以它并不需要STW

### G1在运行过程中的主要模式
* YGC（不同于 CMS）
* 并发阶段
* 混合模式
* Full GC （一般是G1出现问题时发生）
* G1 YGC 在Eden充满时触发，在回收之后所有属于Eden的区块全部变成了空白及不属于任何一个分区（Eden、Survivor、Old）

### Mixed GC 
* 什么时候触发Mixed GC?
* **G1HeapWastPercent** : 在global concurrent marking结束后，我们可以知道old gen regions 中有多个空间要被回收，在每次 Young GC 之后再次发生
Mixed GC之前，会检查垃圾占比是否到达此参数，只有达到了，下次才会发生 Mixed GC
* **G1MixedGCLiveThresholdPercent**: old generation region 中存活对象的占比，只有在此参数之下，才会被选入 CSet
* **G1MixedGCCountTarget**: 一次global concurrent marking 之后，最多执行Mixed GC的次数。
* **G1OldCSetRegionThresholdPercent**: 一次Mixed GC 中能够选入 CSet 的最多old generation region 数量
* 其他参数：
  * -XX:G1HeapRegionSize, 设置Region大小，非最终值
  * -XX:MaxGCPauseMillis, 设置G1收集过程目标时间，默认200ms，不是硬性条件
  * -XX:G1NewSizePercent, 新生代最小值，默认5%
  * -XX:G1MaxNewSizePercent, 新生代最大值，默认60%
  * -XX:ParallelGCThreads, STW期间，并行GC线程数
  * -XX:ConcGCThread, 并发标记阶段，并行执行的线程数
  * -XX:InitiatingHeapOccupancyPercent: 设置触发标记周期的 Java堆占用率阈值。默认值是45%。这里的Java堆占是指的是non_young_capacity_bytes
  包括old + humongous