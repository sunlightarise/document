### 枚举根节点
* 当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，
是使用一组称为OopMap的数据结构来达到这个目的

### 安全点
* 在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系发生变化，或者说OopMap内容变化的
指令非常多，如果为每一条指令都生成对应的OopMap, 那将会需要大量的额外空间，这样GC的空间成本将会变得更高。

* 实际上，HotSpot 并没有为每一条指令都生成OopMap, 而只是在"特定位置"记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有的
地方都停顿下来GC，只有在达到安全点的时候才能暂停。

* Safepoint 的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时负载。所以，安全点的选定基本上是以"**是否具有让程序长时间
执行的特征**" 为标准进行选定的--因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，"长时间执行" 的最明显特征就是指令
序列服用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生 Safepoint.

* 对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都"跑"到最近的安全点上再停顿下来：抢占式中断
（Preemptive Suspension）和主动式中断（Voluntary Suspension）
  * 抢占式中断: 它不需要线程的执行代码主动去配合，在GC发生时，首先把所有的线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它"跑"到安全点
  上。
  * 主动式中断: 当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。
  轮询标志的地方和安全点是重合的，另外再创建对象需要分配内存的地方。
  
  现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件

### 安全区域
* 在使用Safepoint似乎已经完美的解决了如何引进 GC的问题，但实际上情况却并不一定。Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可以进入
GC的Safepoint. 但如果程序在"不执行"的时候呢？ 所谓恒旭不执行就没有分配CPU的时间，典型的例子就是处于Sleep状态或者Blocked状态， 这个时候线程无法
响应JVM的中断请求，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域（Safe Regin）了.

* 在线程执行到了 Safe Region 中的代码时，首先标识自已进入了Safe Region，那样，当在这段时间里JVM要发起GC时， 就不用管标识自己为Safe Region 状态
的线程了。在线程要离开 Safe Region时， 它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可
以安全离开 Safe Region 的信号为止。