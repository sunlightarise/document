### JVM 内存模型

#### 内存结构

1. 虚拟机栈: Stack Frame 栈帧, 方法执行过程中的压栈和出栈的执行过程。
2. 程序计数器 (Program Counter), 字节码执行顺序。
3. 本地方法栈: native 来获取的JVM提供的本地方法。
4. 堆(Heap): JVM管理的最大的一块内存空间。与堆相关的是一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采取的分代收集算法，
所以对空间也是基于这一点进行了相应的划分：新生代与年老代. Eden 空间, From Survivor 空间与 To Survivor 空间。
5. 方法区(Method Area): 存储元数据信息。永久代 (Permanent Generation) 从JDK1.8开始彻底废弃永久代，
使用元空间(Meta Space)来替代。
6. 运行时常量池：方法区的一部分内容。
7. 直接内存： Direct Memory, 堆外内存，不是由JVM来管理，是通过操作系统来管理的。与Java NIO密切相关的。Java 通过DirectByteBuffer来
操作直接内存。

#### Java对象的创建过程

new 关键创建对象的3个步骤
1. 在堆内存中创建出对象的实例。
2. 为对象的实例成员变量赋初始值。
3. 将对象的引用返回。

指针碰撞 (前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间) 
空闲列表 (前提是堆空间中已经被使用，未被使用的是饺子在一起的。这时虚拟机就需要通过一个列表来记录哪些是可以使用的，哪些是已经被使用的，
接下来找出可以容纳新创建的对象的未被使用的空间，再此空间存放对象， 同时还要修改列表上的记录)。

对象在内存中的布局：
1. 对象头
2. 实例数据 (即我们再一个类中声明)
3. 对齐填充 (可选)

引用访问对象的方式:
1. 使用句柄的方式。
2. 使用直接指针的方式。


#### 分析工具jvisualvm

1. 配置JVM参数
```jvm
-Xms2m
-Xmx2m
-XX:+HeapDumpOnOutOfMemoryError

-XX:MaxMetaspaceSize=10m  //设置元空间大小
```

#### Jdk1.8 元空间
