1、kafka的消息是保存在磁盘或者缓存在磁盘上的，一般一位在磁盘上读写数据会降低性能，应为寻址会比较消耗时间，但是实际上，Kafka 的特征就是高吞吐量

2、数据写入：
Kfaka 胡巴收到的消息都写入到磁盘。它绝对不会丢失数据，为了优化写入速度Kafka采用了两个技术，顺序写入和MMFile (Memory Mapped File)

  顺序写入，磁盘的读写快慢取决与读写方式，通常有两种读写方式：
顺序读写，随机读写，在顺序读写情况下，磁盘的顺序读写速度和内存持平。

  Kafka 采用顺序读写I/O,
  特点：
  磁盘的顺序读写速度踩过内存随机读写，
  JVM 的GC效率低，暂用内存大，磁盘可以避免这个问题
　系统冷启动后，磁盘缓存依然可以使用

  kafka 的每个Partition其实都是一个文件，收到消息后Kafka 会把数据插入到文件末尾。
  读取的位置Offset 来标记，SDK 将Offset 存储到Zookeeper

3、Menory Mapped Files 
即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存，所以kafka 的数据不是实时写入硬盘，它从分利用了现代操作系统分页存储来利用内存提醒I/O 效率。

Memory Mapped File 也被翻译为 内存映射文件，在 64位操作系统一般可以表示20G的数据文件，他的工作原理就是直接利用操作系统的Page 来实现文件到物理内存的直接映射

4、 数据读取

基于snedfile 实现Zero Copy (零拷贝)

传统模式：
a、调用Read 函数，文件数据被Copy 到内核缓存区
b、Read 函数返回，文件数据从内核缓冲区Copy 到用户缓冲区
c、Write 函数调用，将文件数据从用户缓冲区Copy 到内核与Socket相关的缓冲区
d、数据从Socket 缓冲区 Copy 到相关协议引擎 。

Sendfile 
流程如下，
a、Sendfile 系统调用，文件数据被Copy 到内核缓冲区
b、再从内核缓冲区 Copy 到内核Socket 相关的缓冲区
c、最后在将Socket相关的缓冲区Copu 到协议引擎


5、批量压缩
为了提升网络IO

a、kafka 采用批量压缩，即将多个消息，一起压缩，而不是单个消息压缩。
b、kafka 允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中一保存压缩格式，直接被消费者解压缩
c、Kafka支持多种压缩协议包括 Gzip 和 Snappy 压缩协议



总结：
1）、Kafka 速度在于，他把每个消息都成了一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap 提高I/O速度
2）、写入数据的时候鱼鱼单个Partion 是末尾添加，所以速度最优；读取数据的时候配合 Sendfile 直接暴力输出。

